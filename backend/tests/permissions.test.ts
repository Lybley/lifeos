/**
 * Permission & Consent System Tests
 */

import { expect } from 'chai';
import { Pool } from 'pg';
import { PermissionService } from '../src/permissions/PermissionService';
import { PermissionScope, PermissionStatus } from '../src/permissions/types';

describe('Permission & Consent System', () => {
  let db: Pool;
  let permissionService: PermissionService;
  const testUserId = 'test-user-123';
  
  before(async () => {
    // Setup database connection
    db = new Pool({
      host: process.env.POSTGRES_HOST || 'localhost',
      port: parseInt(process.env.POSTGRES_PORT || '5432'),
      database: process.env.POSTGRES_DB || 'lifeos_test',
      user: process.env.POSTGRES_USER || 'lifeos_user',
      password: process.env.POSTGRES_PASSWORD || 'lifeos_secure_password_123'
    });
    
    permissionService = new PermissionService(db);
  });
  
  after(async () => {
    // Cleanup
    await db.query('DELETE FROM permissions WHERE user_id = $1', [testUserId]);
    await db.end();
  });
  
  beforeEach(async () => {
    // Clean up before each test
    await db.query('DELETE FROM permissions WHERE user_id = $1', [testUserId]);
  });
  
  describe('Scope Definitions', () => {
    it('should load all scope definitions', async () => {
      const scopes = await permissionService.getScopeDefinitions();
      
      expect(scopes).to.be.an('array');
      expect(scopes.length).to.be.greaterThan(0);
      expect(scopes).to.have.length(11); // All 11 scopes defined
    });
    
    it('should have correct scope properties', async () => {
      const scopes = await permissionService.getScopeDefinitions();
      const emailScope = scopes.find(s => s.scope === PermissionScope.EMAILS_FULL);
      
      expect(emailScope).to.exist;
      expect(emailScope!.name).to.equal('Full Email Access');
      expect(emailScope!.riskLevel).to.equal('medium');
      expect(emailScope!.scopeHash).to.be.a('string');
    });
    
    it('should have high-risk scopes disabled by default', async () => {
      const scopes = await permissionService.getScopeDefinitions();
      const healthScope = scopes.find(s => s.scope === PermissionScope.HEALTH_READ);
      const purchaseScope = scopes.find(s => s.scope === PermissionScope.PURCHASES_WRITE);
      \n      expect(healthScope!.defaultEnabled).to.be.false;\n      expect(purchaseScope!.defaultEnabled).to.be.false;\n    });\n  });\n  \n  describe('Permission Granting', () => {\n    it('should grant permission to user', async () => {\n      const permissionId = await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(permissionId).to.be.a('string');\n      \n      const permission = await permissionService.getPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(permission).to.exist;\n      expect(permission!.scope).to.equal(PermissionScope.EMAILS_METADATA);\n      expect(permission!.status).to.equal(PermissionStatus.ACTIVE);\n    });\n    \n    it('should grant permission with expiration', async () => {\n      const expiresAt = new Date(Date.now() + 86400000); // 24 hours\n      \n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA,\n        { expiresAt }\n      );\n      \n      const permission = await permissionService.getPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA\n      );\n      \n      expect(permission!.expiresAt).to.exist;\n      expect(permission!.expiresAt!.getTime()).to.be.closeTo(\n        expiresAt.getTime(),\n        1000 // Within 1 second\n      );\n    });\n    \n    it('should grant multiple permissions at once', async () => {\n      const scopes = [\n        PermissionScope.EMAILS_METADATA,\n        PermissionScope.FILES_METADATA,\n        PermissionScope.CALENDAR_READ\n      ];\n      \n      const permissionIds = await permissionService.grantPermissions(\n        testUserId,\n        { scopes }\n      );\n      \n      expect(permissionIds).to.have.length(3);\n      \n      const permissions = await permissionService.getUserPermissions(testUserId);\n      expect(permissions).to.have.length(3);\n    });\n    \n    it('should update existing permission instead of creating duplicate', async () => {\n      // Grant first time\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      // Grant again\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA,\n        { reason: 'Re-granted' }\n      );\n      \n      const permissions = await permissionService.getUserPermissions(testUserId);\n      const emailPerms = permissions.filter(\n        p => p.scope === PermissionScope.EMAILS_METADATA && p.status === PermissionStatus.ACTIVE\n      );\n      \n      expect(emailPerms).to.have.length(1);\n    });\n  });\n  \n  describe('Permission Checking', () => {\n    beforeEach(async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n    });\n    \n    it('should check if user has permission', async () => {\n      const result = await permissionService.hasPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(result.allowed).to.be.true;\n      expect(result.scope).to.equal(PermissionScope.EMAILS_METADATA);\n    });\n    \n    it('should return false for permission not granted', async () => {\n      const result = await permissionService.hasPermission(\n        testUserId,\n        PermissionScope.PURCHASES_WRITE\n      );\n      \n      expect(result.allowed).to.be.false;\n      expect(result.reason).to.exist;\n    });\n    \n    it('should check multiple permissions at once', async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA\n      );\n      \n      const results = await permissionService.hasPermissions(\n        testUserId,\n        [\n          PermissionScope.EMAILS_METADATA,\n          PermissionScope.FILES_METADATA,\n          PermissionScope.PURCHASES_WRITE\n        ]\n      );\n      \n      expect(results[PermissionScope.EMAILS_METADATA].allowed).to.be.true;\n      expect(results[PermissionScope.FILES_METADATA].allowed).to.be.true;\n      expect(results[PermissionScope.PURCHASES_WRITE].allowed).to.be.false;\n    });\n  });\n  \n  describe('Permission Revocation', () => {\n    beforeEach(async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA\n      );\n    });\n    \n    it('should revoke permission', async () => {\n      const revoked = await permissionService.revokePermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(revoked).to.be.true;\n      \n      const result = await permissionService.hasPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(result.allowed).to.be.false;\n    });\n    \n    it('should return false when revoking non-existent permission', async () => {\n      const revoked = await permissionService.revokePermission(\n        testUserId,\n        PermissionScope.PURCHASES_WRITE\n      );\n      \n      expect(revoked).to.be.false;\n    });\n    \n    it('should revoke all permissions', async () => {\n      const count = await permissionService.revokeAllPermissions(\n        testUserId,\n        'Testing revoke all'\n      );\n      \n      expect(count).to.equal(2);\n      \n      const permissions = await permissionService.getUserPermissions(\n        testUserId,\n        PermissionStatus.ACTIVE\n      );\n      \n      expect(permissions).to.have.length(0);\n    });\n  });\n  \n  describe('Permission Expiration', () => {\n    it('should expire permissions past expiry date', async () => {\n      // Grant permission that expires in the past\n      const expiredDate = new Date(Date.now() - 86400000); // Yesterday\n      \n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ,\n        { expiresAt: expiredDate }\n      );\n      \n      // Run expiration\n      const count = await permissionService.expirePermissions();\n      \n      expect(count).to.be.greaterThan(0);\n      \n      // Check permission is no longer active\n      const result = await permissionService.hasPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ\n      );\n      \n      expect(result.allowed).to.be.false;\n    });\n    \n    it('should not expire permissions with future expiry', async () => {\n      const futureDate = new Date(Date.now() + 86400000); // Tomorrow\n      \n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ,\n        { expiresAt: futureDate }\n      );\n      \n      await permissionService.expirePermissions();\n      \n      const result = await permissionService.hasPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ\n      );\n      \n      expect(result.allowed).to.be.true;\n    });\n  });\n  \n  describe('Audit Logging', () => {\n    it('should log permission grant', async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA,\n        { reason: 'Test grant' }\n      );\n      \n      const auditLog = await permissionService.getAuditLog(testUserId, {\n        action: 'granted'\n      });\n      \n      expect(auditLog.length).to.be.greaterThan(0);\n      expect(auditLog[0].action).to.equal('granted');\n      expect(auditLog[0].scope).to.equal(PermissionScope.EMAILS_METADATA);\n    });\n    \n    it('should log permission revocation', async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA\n      );\n      \n      await permissionService.revokePermission(\n        testUserId,\n        PermissionScope.FILES_METADATA,\n        { reason: 'Test revoke' }\n      );\n      \n      const auditLog = await permissionService.getAuditLog(testUserId, {\n        action: 'revoked'\n      });\n      \n      expect(auditLog.length).to.be.greaterThan(0);\n      expect(auditLog[0].action).to.equal('revoked');\n      expect(auditLog[0].previousStatus).to.equal(PermissionStatus.ACTIVE);\n      expect(auditLog[0].newStatus).to.equal(PermissionStatus.REVOKED);\n    });\n    \n    it('should log permission usage', async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ\n      );\n      \n      await permissionService.logUsage(\n        testUserId,\n        PermissionScope.CALENDAR_READ,\n        { operation: 'read_events', count: 5 }\n      );\n      \n      const auditLog = await permissionService.getAuditLog(testUserId, {\n        action: 'used'\n      });\n      \n      expect(auditLog.length).to.be.greaterThan(0);\n      expect(auditLog[0].action).to.equal('used');\n      expect(auditLog[0].metadata).to.deep.include({ operation: 'read_events' });\n    });\n  });\n  \n  describe('Permission Summary', () => {\n    beforeEach(async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_FULL\n      );\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.FILES_METADATA\n      );\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.CALENDAR_READ\n      );\n    });\n    \n    it('should get permission summary by category', async () => {\n      const summary = await permissionService.getPermissionSummary(testUserId);\n      \n      expect(summary).to.be.an('array');\n      expect(summary.length).to.be.greaterThan(0);\n      \n      const emailCategory = summary.find((s: any) => s.category === 'email');\n      expect(emailCategory).to.exist;\n      expect(emailCategory.active_permissions).to.be.greaterThan(0);\n    });\n  });\n  \n  describe('Consent Versioning', () => {\n    it('should store consent version with permission', async () => {\n      await permissionService.grantPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      const permission = await permissionService.getPermission(\n        testUserId,\n        PermissionScope.EMAILS_METADATA\n      );\n      \n      expect(permission!.consentVersion).to.exist;\n      expect(permission!.scopeHash).to.be.a('string');\n    });\n    \n    it('should have unique scope hash for each scope', async () => {\n      const scopes = await permissionService.getScopeDefinitions();\n      \n      const hashes = scopes.map(s => s.scopeHash);\n      const uniqueHashes = new Set(hashes);\n      \n      expect(uniqueHashes.size).to.equal(hashes.length);\n    });\n  });\n});\n